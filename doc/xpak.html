<pre>
+-----------------------------------------------------------------------------+
| Copyright (c) 2008-2009 Lars Hartmann                                       |
| All rights reserved.                                                        |
|                                                                             |
| Redistribution with or without modification, is permitted provided that the |
| following condition is met:                                                 |
|                                                                             |
|   Redistributions of this text must retain the above copyright notice and   |
|   this condition.                                                           |
+-----------------------------------------------------------------------------+
</pre>

<h1>The XPAK Data Format</h1>
<h2>Notes</h2>

<h3>Data Types</h3>
  <dl>
      <dt><b>Integer:</b></dt>
      <dd>every offset or length(len) value in this documentation will be an
      unsigned 32bit integer in big endian byte order(32bit unsigned big int
      or uint32(big) ).</dd>
      <dt><b>String:</b></dt>
      <dd>All strings, mentioned in this documentation are ASCII encoded, and
      not nullterminated</dd>
      <dt><b>Values</b></dt>
      <dd>The actual values of the individual xpak entries are stored as
      Strings.</dd>

<h3>Vertical Bars</h3> 

The vertical bars '|' are not part of the file format, they are merely used to
illustrate how the offset values apply to the data.

<h2>Synopsis</h2>
<dl>
    <dt><b>tarball:</b></dt>
    <dd><pre>
     |--xpak_offset--|
[tar]|[    xpak     ]|[xpak_offset]"STOP"
    </pre></dd>
    <dt><b>xpak:</b></dt>
    <dd>
"XPAKPACK"[index_len][data_len][index][data]"XPAKSTOP"
    </dd>
    <dt><b>index:</b></dt>
    <dd><pre>
|--------------index_len--------------|
|[index1][index2][index3][index4][...]|
    </pre></dd>
    <dt><b>indexN:</b></dt>
    <dd><pre>
          |--name_len--|
[name_len]|[   name   ]|[data_offset][data_len]
    </dd></pre>
    <dt><b>data:</b></dt>
    <dd><pre>
|-------------data_len------------|
|-dataN_offset-|-dataN_len-|
|[    data    ]|[ data_N  ]|[data]|
    </pre></pre>
</dl>

<h2>Detailed</h2>
<p>
    Every gentoo binary package has a xpak attached to it which contains
    build time information like the use flags it was built with, the ebuild
    it was built from, the environmental variables, CFLAGs, CXXFLAGs, ....
</p>
<h3>lets have a look at this XPAK:</h3>
<p>
    If you look at a gentoo binary package (binpkg) with a hex-editor you'll
    notice the behinf the data, which belongs to the tarball you find a binary
    blob - the [xpak], an offset which holds the bytes from the start of the
    [xpak] to the end of the file - [xpak_offset] and finally the String
    "STOP":
<p>
<pre>
              |-xpak_offset-|
        [tbz2]|[    xpak   ]|[xpak_offset]"STOP"|
</pre>
<p>
    Here you see the tbz2 archive, and the attached xpak-blob, the xpak-offset
    and the string "STOP" at the end.
</p>
<p>
    If we read the offset value and count [offset] bytes backwards from the
    start of xpak_offset, we have found the start of the XPAK Block which
    starts with the String "XPAKPACK". This xpak block consists of the string
    "XPAKPACK", the length of the index block - [index-len], the length of the
    data block - [data-len], an [index-len] bytes long binary blob with the
    index, a [data-len] bytes long binary blob with the data and the string
    "XPAKSTOP" at the end:
</p>
<pre>
                                       |-index_len-|-data_len-|
        "XPAKPACK"[index_len][data_len]|[  index  ]|[  data  ]|"XPAKSTOP"
</pre>
<p>
    To actually get the index and the data, we cut out [index_len] bytes after
    the end of [data_len] for the index block and then cut out the next
    [data_len] bytes for the data block. If we have done everything right up
    to this point, the following bytes would be the ASCII formatted string
    "XPAKSTOP".
</p>
<p>
    The actual data is truncated into one big block - so if we want to read it we
    need the actual positions of each information in this big data block, this
    information can be obtained using the indices which are stored in the index
    block.
</p>
<p>
    Now we take a closer look at the index block: The index block consists of
    several truncated index blocks:
</p>
<pre>
        |------------------------index_len-----------------------|
        |[index1][index2][index3][index4][index5][index6][index7]|
</pre>
<p>
    The index block holds all information we need to find the data we want in the
    [data] block. It consists of truncated index elements with a length
    [index_len]. Each of those index elements stands for one information in the
    data block and consists of the length of its name ([name_len]), a [name_len]
    bytes long string (the Name of the data block), this index belongs to, the
    offset of the data block (data_offset) and the length of that data block
    ([data_len]):
</p>
<pre>
                  |-name_len-|
        [name_len>|[  name  ]|[dataN_offset][dataN_len]
</pre>
<p>
    Now lets take a closer look at the data block: the data block contains
    truncated data blocks with a total length of [data_len]:
</p>
<pre>
        |-------------------------data_len-------------------------|
        |[data1][data2][data3][data4][data5][data6][data7][data...]|
</pre>
<p>
    This binary block is [data_len] bytes long and consists of truncated data.
</p>
<p>
    To select one data element, we need the [data_offset] and the [data_len]
    from the index, if we have those we can count [data_offset] bytes from the
    start of the data block, and then cut out the next [data_len] bytes. there
    we got our data block:
 </p>
<pre>
        |------dataN_offset------|[--dataN_len-]|
        |[data1data2data3data...]|[data-we-want]|
</pre>
